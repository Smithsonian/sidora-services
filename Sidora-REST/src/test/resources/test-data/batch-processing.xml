<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright 2015-2016 Smithsonian Institution.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License"); you may not
  ~ use this file except in compliance with the License.You may obtain a copy of
  ~ the License at: http://www.apache.org/licenses/
  ~
  ~ This software and accompanying documentation is supplied without
  ~ warranty of any kind. The copyright holder and the Smithsonian Institution:
  ~ (1) expressly disclaim any warranties, express or implied, including but not
  ~ limited to any implied warranties of merchantability, fitness for a
  ~ particular purpose, title or non-infringement; (2) do not assume any legal
  ~ liability or responsibility for the accuracy, completeness, or usefulness of
  ~ the software; (3) do not represent that use of the software would not
  ~ infringe privately owned rights; (4) do not warrant that the software
  ~ is error-free or will be maintained, supported, updated or enhanced;
  ~ (5) will not be liable for any indirect, incidental, consequential special
  ~ or punitive damages of any kind or nature, including but not limited to lost
  ~ profits or loss of data, on any basis arising from contract, tort or
  ~ otherwise, even if any of the parties has been warned of the possibility of
  ~ such loss or damage.
  ~
  ~ This distribution includes several third-party libraries, each with their own
  ~ license terms. For a complete copy of all copyright and license terms, including
  ~ those of third-party libraries, please see the product release notes.
  -->

<!--<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.1.0"
           xmlns:jaxrs="http://cxf.apache.org/blueprint/jaxrs"
           xmlns:cxf="http://cxf.apache.org/blueprint/core"
           xmlns:camel="http://camel.apache.org/schema/blueprint"
           xmlns:camelcxf="http://camel.apache.org/schema/blueprint/cxf"
           xsi:schemaLocation="
             http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
             http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.1.0 http://aries.apache.org/schemas/blueprint-cm/blueprint-cm-1.1.0.xsd
             http://cxf.apache.org/blueprint/jaxrs http://cxf.apache.org/schemas/blueprint/jaxrs.xsd
             http://cxf.apache.org/blueprint/core http://cxf.apache.org/schemas/blueprint/core.xsd
             http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint.xsd
             http://camel.apache.org/schema/blueprint/cxf http://camel.apache.org/schema/blueprint/cxf/camel-cxf.xsd">-->
<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.1.0"
           xmlns:jaxrs="http://cxf.apache.org/blueprint/jaxrs"
           xmlns:cxf="http://cxf.apache.org/blueprint/core"
           xmlns:camel="http://camel.apache.org/schema/blueprint"
           xmlns:camel-cxf="http://camel.apache.org/schema/blueprint/cxf"
           xsi:schemaLocation="
             http://www.osgi.org/xmlns/blueprint/v1.0.0 https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
             http://cxf.apache.org/blueprint/jaxrs http://cxf.apache.org/schemas/blueprint/jaxrs.xsd
             http://cxf.apache.org/blueprint/core http://cxf.apache.org/schemas/blueprint/core.xsd">

    <!-- OSGI blueprint property placeholder -->
    <!-- The properties should not be changed from karaf or external cfg if there are deployments currently being ingested
        as it would cause the camel context to reload and error out any in-flight ingestion processes. -->
    <cm:property-placeholder id="sidora.karaf.properties" persistent-id="edu.si.sidora.karaf" update-strategy="reload">
        <cm:default-properties>
            <cm:property name="edu.si.batch" value="edu.si.batch"/>
            <!--<cm:property name="router.address" value="/sidora/rest"/>-->
            <cm:property name="service.address" value="/sidora/rest"/> <!-- http://localhost:8181/cxf/sidora/rest -->
        </cm:default-properties>
    </cm:property-placeholder>


    <bean id="processBatchCorrelationId" class="edu.si.services.sidora.rest.batch.processor.ProcessBatchCorrelationId"/>
    <bean id="processFileURL" class="edu.si.services.sidora.rest.batch.processor.ProcessFileURL"/>
    <bean id="processMoveStagedFilesToProcessDir" class="edu.si.services.sidora.rest.batch.ProcessMoveStagedFilesToProcessDir"/>

    <bean id="responseControllerBean" class="edu.si.services.sidora.rest.batch.ResponseControllerBean"/>

    <bean id="statusResponseControllerBean" class="edu.si.services.sidora.rest.batch.model.StatusResponseControllerBean"/>

    <!--<bean id="fcrepoConfiguration" class="edu.si.services.camel.fcrepo.FcrepoConfiguration">
        <property name="fedoraHost" value="${si.fedora.host}"/>
        <property name="authUsername" value="${si.fedora.user}"/>
        <property name="authPassword" value="${si.fedora.password}"/>
    </bean>

    <bean id="fusekiHttpHeaderFilterStrategy" class="org.apache.camel.impl.DefaultHeaderFilterStrategy">
        <property name="outFilter">
            <set>
                <value>ManifestXML</value>
                <value>CamelSchematronValidationReport</value>
                <value>Content-Type</value>
            </set>
        </property>
    </bean>-->

    <!-- The camel route context -->
    <camelContext id="RestService"
                  xmlns="http://camel.apache.org/schema/blueprint"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                  xmlns:objDatastreams="http://www.fedora.info/definitions/1/0/access/"
                  xmlns:findObjects="http://www.fedora.info/definitions/1/0/types/"
                  xmlns:ri="http://www.w3.org/2005/sparql-results#"
                  xmlns:fits="http://hul.harvard.edu/ois/xml/ns/fits/fits_output"
                  xmlns:fedora="info:fedora/fedora-system:def/relations-external#"
                  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                  xmlns:eac="urn:isbn:1-931666-33-4"
                  xmlns:mods="http://www.loc.gov/mods/v3"
                  xsi:schemaLocation="http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint-2.16.3.xsd"
                  trace="false" useMDCLogging="true" useBreadcrumb="false">
        <!--
          The "unused" namespace definitions above are needed to deal with the way Camel handles namespaces in XPath.
        -->
        <!-- Using a Camel properties component and referring to the blueprint property placeholder by its ID. -->
        <propertyPlaceholder id="properties"
                             location="blueprint:sidora.karaf.properties,file:${karaf.home}/etc/system.properties"/>

        <route id="BatchProcessResourceStartProcessing">
            <from uri="file:target/BatchProcessData?minDepth=3&amp;moveFailed=Error_BatchProcess&amp;move=Done&amp;maxMessagesPerPoll=1"/>
            <log message="${id}: Starting Batch Processing ..."
                 loggingLevel="INFO"
                 logName="{{edu.si.batch}}"/>

            <setHeader headerName="batchProcessingComplete">
                <simple>
                    false
                </simple>
            </setHeader>

            <setHeader headerName="metadataXML">
                <simple>

                </simple>
            </setHeader>

            <transform>
                <simple>${header.CamelFileName}</simple>
            </transform>

            <process ref="processMoveStagedFilesToProcessDir"/>

            <to uri="reader:file"/>

            <convertBodyTo type="java.lang.String"/>

            <log message="======================= [ The Metadata File ] =======================\nHeaders:\n${headers}"
                 loggingLevel="INFO"
                 logName="{{edu.si.batch}}"/>


        </route>

        <route id="BatchProcessContentModel">
            <from uri="direct:processContentModel"/>
            <log message="${id} Batch Process: Starting Content Model processing ..."
                 loggingLevel="DEBUG"
                 logName="edu.si.batch"/>

            <!-- Get the PID of the FDO that was just operated upon. -->
            <log message="${id} Batch Process: PID: ${headers.parentId}"
                 loggingLevel="DEBUG"
                 logName="edu.si.batch"/>
            <setHeader headerName="CamelFedoraPid">
                <simple>
                    ${headers.parentId}
                </simple>
            </setHeader>

            <!-- Get the DSID from the Atom message if any. -->
            <!--<setHeader headerName="DSID">
                <xpath resultType="java.lang.String">
                    /atom:entry/atom:category[@scheme="fedora-types:dsID"]/@term
                </xpath>
            </setHeader>
            <log message="${id} Batch Process: Atom DSID: ${headers.DSID}"
                 loggingLevel="DEBUG"
                 logName="edu.si.batch"/>-->

            <!-- Get the Content Models for the FDO and put them on a list. -->
            <!--<to uri="fedora://getDatastreamDissemination?dsId=RELS-EXT&amp;exchangePattern=InOut"/>
            <convertBodyTo type="java.lang.String" charset="utf-8"/>
            <log message="${id} Batch Process: RELS-EXT: ${body}"
                 loggingLevel="DEBUG"
                 logName="edu.si.batch"/>
            <split strategyRef="modelAggregator">
                <xpath>
                    //fs:hasModel/@rdf:resource
                </xpath>
                <log message="${id} Batch Process: Split Content Model. BODY: ${body}"
                     loggingLevel="DEBUG"
                     logName="edu.si.batch"/>
            </split>-->
            <log message="${id} Batch Process: Content Model: ${header.contentModel}"
                 loggingLevel="DEBUG"
                 logName="edu.si.batch"/>

            <choice> <!-- Filter by content model. -->
                <when> <!-- If imageCModel or generalImageCModel, and the DSID is "OBJ" - process the image." -->
                    <spel>
                        #{(request.headers[contentModel].contains('info:fedora/si:imageCModel') or
                          request.headers[contentModel].contains('info:fedora/si:generalImageCModel')) and
                          request.headers[DSID] == 'OBJ'}
                    </spel>
                    <log message="${id} Batch Process: Found Image."
                         loggingLevel="DEBUG"
                         logName="edu.si.batch"/>
                    <to uri="direct:processImage"/>
                </when>
                <when> <!-- If imageCModel or generalImageCModel, and the DSID is "OBJ" - process the image." -->
                    <spel>
                        #{request.headers[contentModel].contains('info:fedora/si:fieldbookCModel') and
                          request.headers[DSID] == 'OBJ'}
                    </spel>
                    <log message="${id} Batch Process: Found PDF."
                         loggingLevel="DEBUG"
                         logName="edu.si.batch"/>
                    <to uri="direct:processPDF"/>
                </when>
                <when> <!-- If imageCModel or generalImageCModel, and the DSID is "OBJ" - process the image." -->
                    <spel>
                        #{request.headers[contentModel].contains('info:fedora/si:datasetCModel') and
                          request.headers[DSID] == 'OBJ'}
                    </spel>
                    <log message="${id} Batch Process: Found Dataset."
                         loggingLevel="DEBUG"
                         logName="edu.si.batch"/>
                    <to uri="direct:processDataset"/>
                </when>
                <when> <!-- If sp-audioCModel, and the DSID is "OBJ" - process the audio file." -->
                    <spel>
                        #{request.headers[contentModel].contains('info:fedora/islandora:sp-audioCModel') and
                          request.headers[DSID] == 'OBJ'}
                    </spel>
                    <log message="${id} Batch Process: Found Audio."
                         loggingLevel="DEBUG"
                         logName="edu.si.batch"/>
                    <to uri="direct:processAudio"/>
                </when>

                <when> <!-- If sp_videoCModel, and the DSID is "OBJ" - process the video file." -->
                    <spel>
                        #{request.headers[contentModel].contains('info:fedora/islandora:sp_videoCModel') and
                          request.headers[DSID] == 'OBJ'}
                    </spel>
                    <log message="${id} Batch Process: Found Video."
                         loggingLevel="DEBUG"
                         logName="edu.si.batch"/>
                    <to uri="direct:processVideo"/>
                </when>

                <otherwise> <!-- No supported content model was found. -->
                    <log message="${id} Batch Process: No message processing required."/>
                </otherwise>
            </choice>

            <log message="${id} Batch Process: Finished Message processing."
                 loggingLevel="DEBUG"
                 logName="edu.si.batch"/>
        </route>

        <route id="BatchProcessProcessImage">
            <from uri="direct:processImage"/>
            <log message="${id} BatchProcess: Starting Image processing ..."
                 loggingLevel="DEBUG"
                 logName="edu.si.batch"/>

            <!-- We could submit the file to FITS processing to get the MIME but that can be complicated. -->
            <!-- We could get the MIME type from the datastream metadata or FITS (or both and compare). -->
            <!-- For now we will just trust Fedora's datastream metadata. -->
            <!-- We really should only make new derivatives if the OBJ has changed. -->

            <!-- Get the MIME type from. -->

            <!-- Content by image format. -->
            <!--
            &lt;!&ndash; If the image is a JPEG? Add an archival JPEG2000 and a thumbnail to the FDO. &ndash;&gt;
            ${header.dsMIME} == 'image/jpg' || ${header.dsMIME} == 'image/jpeg' || ${header.dsMIME} == 'image/jpe' ||
            &lt;!&ndash; If the image is a TIFF? Add a JPG datastream and thumbnail for the image to the FDO. &ndash;&gt;
            ${header.dsMIME} == 'image/tiff' || ${header.dsMIME} == 'image/tif' ||
            &lt;!&ndash; If the image is a JPEG2000? Add a JPG datastream and thumbnail to the FDO. &ndash;&gt;
            ${header.dsMIME} == 'image/jp2' ||
            &lt;!&ndash; If the image is a PNG, GIF, BMP? Add a JPG datastream and thumbnail for the image to the FDO. &ndash;&gt;
            ${header.dsMIME} == 'image/png' || ${header.dsMIME} == 'image/gif' || ${header.dsMIME} == 'image/bmp'
            -->
            <!-- If the image is some other MIME type, just log a warning? -->
            <!--<log message="${id} Batch Process: Unsupported image type found. MIME: ${headers.dsMIME}"
                 loggingLevel="WARN"/>-->


            <recipientList> <!-- Delete the temporary file. Note: This approach is Unix specific. -->
                <simple>
                    exec:rm?args=-f ${header.CamelFileNameProduced}
                </simple>
            </recipientList>
            <choice>
                <when>
                    <simple>
                        ${headers.CamelExecExitValue} != 0
                    </simple>
                    <log message="${id} Batch Process: Unable to delete working file. Filename: ${headers.CamelFileNameProduced}"
                         loggingLevel="WARN"/>
                    <!-- We also want to proactively tell monitoring -->
                </when>
            </choice>

            <log message="${id} Batch Process: Finished Image processing."
                 loggingLevel="DEBUG"
                 logName="edu.si.batch"/>
        </route>


        <!--<route id="BatchProcessAddResource" trace="true" autoStartup="false">
            <from uri="direct:addResource"/>
            <log message="${id}: Started Resource processing ..."
                 loggingLevel="INFO"
                 logName="{{edu.si.batch}}"/>

            &lt;!&ndash; Spelled this way for the MODS XSLT parameter. &ndash;&gt;
            <setHeader headerName="imageid">
                <xpath logNamespaces="false" resultType="java.lang.String" headerName="ManifestXML">
                    //ImageFileName[text()=$in:body]/parent::Image/ImageId/text()
                </xpath>
            </setHeader>
            &lt;!&ndash; Image Sequence ID used in MODS datastream. &ndash;&gt;
            <setHeader headerName="ImageSequenceID">
                <xpath logNamespaces="false" resultType="java.lang.String" headerName="ManifestXML">
                    //ImageFileName[text()=$in:body]/parent::Image/parent::ImageSequence/ImageSequenceId/text()
                </xpath>
            </setHeader>
            <setHeader headerName="ImageSequenceIndex">
                <xpath logNamespaces="false" resultType="java.lang.Integer" headerName="ManifestXML">
                    //ImageFileName[text()=$in:body]/parent::Image/ImageOrder/text()
                </xpath>
            </setHeader>
            <choice>
                <when>
                    <simple>
                        ${header.ImageSequenceIndex} == ''
                    </simple>
                    &lt;!&ndash; Stop processing this deployment. &ndash;&gt;
                    <log message="${id}: Image sequence does not exist."
                         loggingLevel="WARN"
                         logName="{{edu.si.batch}}"/>
                    <throwException ref="noImageSequence"/>
                </when>
            </choice>

            <setHeader headerName="ImageSequenceCount">
                <xpath logNamespaces="false" resultType="java.lang.Integer" headerName="ManifestXML">
                    count(//Image[../ImageSequenceId=$ImageSequenceID])
                </xpath>
            </setHeader>
            <log message="${id}: Label - ${body}  imageid - ${header.imageid}  ImageSequenceIndex - ${header.ImageSequenceIndex}"
                 loggingLevel="DEBUG"
                 logName="{{edu.si.batch}}"/>
            <log message="${id}: Label - ${body}  ImageSequenceID - ${header.ImageSequenceID}  ImageSequenceCount - ${header.ImageSequenceCount}"
                 loggingLevel="DEBUG"
                 logName="{{edu.si.batch}}"/>

            <to uri="reader:file"/>

            <toD uri="fedora:create?pid=null&amp;owner={{si.ct.owner}}&amp;namespace={{si.ct.namespace}}&amp;label=${header.imageid}"/>

            <toD uri="fedora:addDatastream?name=OBJ&amp;type=image/jpeg&amp;group=M&amp;dsLabel=${header.imageid}&amp;versionable=false"/>

            &lt;!&ndash;<multicast>&ndash;&gt;
            <to uri="direct:createThumbnail"/>
            &lt;!&ndash; <to uri="direct:createArchivalImage" /> &ndash;&gt;
            &lt;!&ndash; We may also want a DISPLAY datastream. &ndash;&gt;
            &lt;!&ndash;</multicast>&ndash;&gt;
            <to uri="velocity:file:Input/templates/CTImageResourceTemplate.vsl"/>
            <to uri="fedora:addDatastream?name=RELS-EXT&amp;group=X&amp;dsLabel=RDF%20Statements%20about%20this%20object&amp;versionable=false"/>
            <to uri="direct:addFITSDataStream"/>
            <to uri="direct:addMODSDataStream"/>

            &lt;!&ndash; We only want to validate one ImageSequenceId so use a Filter on the CamelSplitIndex from the split in
                the processResources calling the addMODSDatastream to get the PID for the first MODS datastream being created &ndash;&gt;
            <filter>
                <simple>
                    ${property.CamelSplitIndex} &lt;= 0
                </simple>
                <setHeader headerName="ImageResourcePID">
                    <simple>
                        ${header.CamelFedoraPid}
                    </simple>
                </setHeader>
            </filter>

            &lt;!&ndash; The current route only handles JPG. &ndash;&gt;
            <choice>
                &lt;!&ndash; If the image is a JPEG? Do nothing. &ndash;&gt;
                <when>
                    <simple>
                        ${header.dsMIME} == 'image/jpg' || ${header.dsMIME} == 'image/jpeg' || ${header.dsMIME} == 'image/jpe'
                    </simple>
                    <log message="${id}: Batch Process: Found JPEG."
                         loggingLevel="DEBUG"
                         logName="{{edu.si.batch}}"/>
                    &lt;!&ndash; Future: Make a JPEG2000 archival image and store it in the MASTER datastream. &ndash;&gt;
                </when>
                &lt;!&ndash; Just warn for now. &ndash;&gt;
                <otherwise>
                    <log message="${id}: Batch Process: Found non-JPEG Image."
                         loggingLevel="WARN"
                         logName="{{edu.si.batch}}"/>
                </otherwise>
            </choice>

            <log message="${id}: Finished Image processing."
                 loggingLevel="INFO"
                 logName="{{edu.si.batch}}"/>
        </route>-->
    </camelContext>

</blueprint>